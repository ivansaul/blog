{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to my personal blog, where I share my journey and insights into the world of programming. Here, you'll find posts about <code>Python</code>, <code>Dart</code>, <code>Flutter</code>, <code>Swift</code>, <code>SwiftUI</code>, <code>Linux</code>, and everything that fuels my passion for code. Whether you're here to learn, explore, or connect, I hope you find inspiration in these pages.</p> <ul> <li> Swift</li> <li> SwiftUI</li> <li> Linux</li> <li> Apps</li> </ul>"},{"location":"apps/","title":"Apps","text":"<p>In this section, we explore the apps I use frequently, diving into their installation, configuration, and usage. You'll also find helpful guides, tips, and even alternatives to these tools.</p> <ul> <li> Xcode How to Customize File Headers</li> <li> Teldrive Free Unlimited Cloud Storage</li> </ul>"},{"location":"apps/drive/teldrive-free-unlimited-cloud-storage/","title":"Teldrive Free Unlimited Cloud Storage","text":"<p><code>Teldrive</code> is a free and open-source alternative to <code>Google Drive</code>, <code>Dropbox</code>, <code>OneDrive</code>, etc. It is a self-hosted file storage system that allows us to store our files in the cloud and share them with others. Teldrive uses the <code>Telegram API</code> for the free unlimited cloud storage.</p> <p></p>"},{"location":"apps/drive/teldrive-free-unlimited-cloud-storage/#prerequisites","title":"Prerequisites","text":"<p>Before starting, make sure you have active Telegram and Supabase accounts.</p>"},{"location":"apps/drive/teldrive-free-unlimited-cloud-storage/#creating-a-telegram-application","title":"Creating a Telegram application","text":"<p>Follow the official guide to create a new Telegram application. After creating the application, you will get an <code>APP api_id</code> and <code>APP api_hash</code>. Copy these values and save them somewhere safe.</p>"},{"location":"apps/drive/teldrive-free-unlimited-cloud-storage/#creating-a-telegram-bot","title":"Creating a Telegram bot","text":"<p>Create a new Telegram bot by following the official guide. After creating the bot, you will get a <code>BOT token</code>. Copy this value and save it somewhere safe.</p> <p>Tip</p> <p>Create at least a couple of bots for better teldrive performance.</p>"},{"location":"apps/drive/teldrive-free-unlimited-cloud-storage/#creating-a-supabase-project","title":"Creating a Supabase project","text":"<ul> <li>Go to Supabase Dashboard and create a new project.</li> </ul> <ul> <li>After creating the project, we need to reveal the <code>connections string URI</code>, click on the <code>connect</code> button on the top right corner of the window.</li> </ul> <ul> <li>Copy the <code>connection string URI</code> and save it somewhere safe. The <code>password</code> is the previous <code>password</code> we used when creating the project.</li> </ul>"},{"location":"apps/drive/teldrive-free-unlimited-cloud-storage/#setting-up-teldrive","title":"Setting up Teldrive","text":"<p>The setup process a quite simple. Just follow the steps below:</p> <ul> <li> <p>Download the <code>teldrive</code> binary for your system from the release page.</p> </li> <li> <p>Create a <code>config.toml</code> file in the same directory as the <code>teldrive</code> binary.</p> </li> </ul> config.toml<pre><code>[db]\ndata-source = \"postgresql://postgres.[PROJECT-ID]:[YOUR-PASSWORD]@aws-.../postgres\" # (1)!\nprepare-stmt = false\n\n[db.pool]\nenable = false\n\n[jwt]\nallowed-users = [\"YOUR-TELEGRAM-USERNAME\"]\nsecret = \"YOUR-SECRET\" # (2)!\n\n[tg]\napp-id = 123456789 # (3)!\napp-hash = \"abcdefghijklmnopqrstuvwxyz\" # (4)!\nsession-file = \"session.db\"\n</code></pre> <ol> <li> <p>Replace <code>[PROJECT-ID]</code> and <code>[YOUR-PASSWORD]</code> with the values you got previously.</p> </li> <li> <p>Generate a random string for <code>[YOUR-SECRET]</code> from here.</p> </li> <li> <p>Replace with your Telegram <code>app_id</code> from the previous step.</p> </li> <li> <p>Replace with your Telegram <code>app_hash</code> from the previous step.</p> </li> </ol> <p>Note</p> <p>For more information about the configuration file, check the official documentation</p>"},{"location":"apps/drive/teldrive-free-unlimited-cloud-storage/#running-teldrive","title":"Running Teldrive","text":"<p>Once you have completed the configuration and the installation, you can start teldrive by running the following command:</p> <pre><code>./teldrive run -c config.toml # (1)!\n</code></pre> <ol> <li>Windows users should use <code>.\\teldrive.exe run -c config.toml</code> instead.</li> </ol> Linux and macOS <p>If you are using Linux or MacOS, you need to make the binary executable first. You can do this by running the following command:</p> <pre><code>chmod +x teldrive\n</code></pre> <p>Now, you can access your Teldrive instance by visiting <code>http://localhost:8080</code> in your browser.</p>"},{"location":"apps/drive/teldrive-free-unlimited-cloud-storage/#account-setup","title":"Account setup","text":"<p>After starting teldrive, login using your Telegram credentials.</p> <p>Go to the <code>Settings</code>, and click on the <code>Account</code> tab.</p> <p></p> <ol> <li>Add the <code>Telegram bots</code> that previously created. You can add as many bots as you want.</li> <li>Select the <code>Telegram channel</code> that <code>Teldrive</code> will use to save your files.</li> </ol> <p>That's it! Now you have a working <code>Teldrive</code> instance.</p> <p></p>"},{"location":"apps/xcode/xcode-how-to-customize-file-headers/","title":"Xcode How to Customize File Headers","text":"<p>When we create a new file in Xcode, it automatically adds a comment at the top of the file with some information about the file, such as the file name, author, and creation date and so on. Sometimes we need to add some custom information like the version of the project, links to the repository or any other information that we want to keep in the file. In this guide we will learn step by step how to customize the headers using a custom <code>.plist</code> file.</p>"},{"location":"apps/xcode/xcode-how-to-customize-file-headers/#create-a-plist-file","title":"Create a <code>.plist</code> file","text":"<p>First, we need to create an empty file named <code>IDETemplateMacros.plist</code> with any text editor, in this case we will use <code>neovim</code>.</p> <pre><code>nvim IDETemplateMacros.plist\n</code></pre> <p>Next, add the following content to the file.</p> IDETemplateMacros.plist<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;\n&lt;plist version=\"1.0\"&gt;\n&lt;dict&gt;\n&lt;key&gt;FILEHEADER&lt;/key&gt;\n&lt;string&gt;\n//  ___FILENAME___\n//  ___PACKAGENAME___\n//\n//  Created by @ivansaul on ___DATE___.\n//\n//  https://github.com/ivansaul\n//&lt;/string&gt;\n&lt;/dict&gt;\n&lt;/plist&gt;\n</code></pre> <p>After adding the content, you should see something like this:</p> <p></p> <p>Note</p> <p><code>FILEHEADER</code>, <code>PACKAGENAME</code>, and <code>DATE</code> are text macros that will be replaced with the actual values when the file is created. We can find the list of all available text macros here: Text macros reference.</p>"},{"location":"apps/xcode/xcode-how-to-customize-file-headers/#add-the-plist-file-to-xcode","title":"Add the <code>.plist</code> file to Xcode","text":"<p>Now we need to put the <code>.plist</code> file in the right place, where Xcode will be able to find it. Xcode will look for the <code>.plist</code> file in the following locations:</p>"},{"location":"apps/xcode/xcode-how-to-customize-file-headers/#globally-for-xcode","title":"Globally for Xcode","text":"<pre><code>~/Library/Developer/Xcode/UserData/\n</code></pre>"},{"location":"apps/xcode/xcode-how-to-customize-file-headers/#project-single-user","title":"Project (single user)","text":"<pre><code>&lt;project-name&gt;.xcodeproj/xcuserdata/&lt;username&gt;.xcuserdatad/\n</code></pre>"},{"location":"apps/xcode/xcode-how-to-customize-file-headers/#project-all-users","title":"Project (all users)","text":"<pre><code>&lt;project-name&gt;.xcodeproj/xcshareddata/\n</code></pre>"},{"location":"apps/xcode/xcode-how-to-customize-file-headers/#workspace-single-user","title":"Workspace (single user)","text":"<pre><code>&lt;workspace-name&gt;.xcworkspace/xcuserdata/&lt;username&gt;.xcuserdatad/\n</code></pre>"},{"location":"apps/xcode/xcode-how-to-customize-file-headers/#workspace-all-users","title":"Workspace (all users)","text":"<pre><code>&lt;workspace-name&gt;.xcworkspace/xcshareddata/\n</code></pre> <p>Example</p> <p>If you really want to use in all your projects, you could copy the <code>.plist</code> file to the following location: <pre><code>cp IDETemplateMacros.plist ~/Library/Developer/Xcode/UserData/IDETemplateMacros.plist\n</code></pre></p>"},{"location":"apps/xcode/xcode-how-to-customize-file-headers/#use-multiple-plist-files","title":"Use multiple <code>.plist</code> files","text":"<p>We can use multiple <code>IDETemplateMacros.plist</code> files simultaneously, for example, we can have a global one in the following location:</p> <pre><code>~/Library/Developer/Xcode/UserData/IDETemplateMacros.plist\n</code></pre> <p>And a project specific one in the following location:</p> <pre><code>&lt;project-name&gt;.xcodeproj/xcuserdata/&lt;username&gt;.xcuserdatad/IDETemplateMacros.plist\n</code></pre> <p>Note</p> <p>The project specific one will override the global one.</p> <p>That's it, now we can create new files in Xcode and the headers will be customized, like this:</p> <p></p>"},{"location":"linux/","title":"Linux","text":"<p>GNU/Linux is a powerful and versatile open-source operating system that serves as the backbone for servers, desktops, and embedded systems worldwide. It is known for its flexibility, extensive community support, and the ability to customize nearly every aspect of the system.</p> <p>In this section, we cover a variety of topics, from installation guides to troubleshooting common issues and configuring popular distributions like Arch Linux, Ubuntu, and Debian.</p> <ul> <li> Opening Ports on Oracle Cloud Instances</li> </ul>"},{"location":"linux/guides/opening-ports-on-oracle-cloud-instances/","title":"Opening Ports on Oracle Cloud Instances","text":"<p>Oracle Cloud Infrastructure (OCI) provides a range of services that allow you to build, run, and manage applications in the cloud. One of the key services is the Oracle Cloud Instance, a virtual machine you can use to run your applications.</p> <p>In this tutorial, we will learn how to open ports on an Oracle Cloud Instance. This is particularly useful when you want to allow incoming traffic on specific ports, such as port 80 for HTTP traffic.</p>"},{"location":"linux/guides/opening-ports-on-oracle-cloud-instances/#adding-ingress-rules","title":"Adding Ingress Rules","text":"<p>Follow these steps to add ingress rules to your Oracle Cloud Instance:</p> <ul> <li>Log in to the Oracle Cloud Console.</li> <li>Navigate to the Compute menu and select Instances.</li> <li>Select the instance where you want to open a port.</li> <li>Click on the Subnet link.</li> </ul> <p></p> <ul> <li>Go to the Security Lists option.</li> </ul> <p></p> <ul> <li>Click on the Ingress Rules tab.</li> </ul> <p></p> <ul> <li>Add a new rule.</li> </ul> <p></p>"},{"location":"linux/guides/opening-ports-on-oracle-cloud-instances/#modifying-iptables","title":"Modifying iptables","text":"<p>Next, SSH into the instance and modify the iptables to allow incoming traffic on the desired port.</p> <p>Info</p> <p>The following steps assume your instance is running on a Ubuntu Linux distribution.</p> <ol> <li> <p>SSH into the instance using the <code>ssh</code> command:</p> <pre><code>ssh -i &lt;path-to-private-key&gt; &lt;username&gt;@&lt;instance-ip&gt;\n</code></pre> </li> <li> <p>Modify the iptables rules file using a text editor like <code>nano</code> or <code>vim</code>:</p> <pre><code>sudo nano /etc/iptables/rules.v4\n</code></pre> </li> <li> <p>Add the following line to allow traffic on the desired port (e.g., port 80):</p> <pre><code>-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT\n</code></pre> </li> <li> <p>Save the changes and exit the editor.</p> </li> <li> <p>Apply the updated iptables rules:</p> <pre><code>sudo iptables-restore &lt; /etc/iptables/rules.v4\n</code></pre> </li> </ol> <p>That's it! Your instance should now accept incoming traffic on the specified port. You can test it by accessing the instance using the URL:</p> <pre><code>http://&lt;instance-ip&gt;:80\n</code></pre>"},{"location":"swift/","title":"Swift","text":"<p>Swift is a general-purpose programming language developed by Apple Inc. for iOS, macOS, watchOS, and tvOS. It is designed to be safe, fast, and expressive, with features such as optionals, error handling, generics, and closures.</p> <ul> <li> How to Sort Arrays in Swift</li> <li> Extensions in Swift</li> <li> How to get a sublist from a list in Swift</li> </ul>"},{"location":"swift/continued-learning/extensions-in-swift/","title":"Extensions in Swift","text":"<p><code>Extensions</code> in Swift allow us to add new functionality to existing <code>Classes</code>, <code>Structures</code>, <code>Enumerations</code>, or <code>Protocol</code> types. This includes adding new methods, properties, initializers, and more. Extensions are particularly useful for organizing and modularizing our code without needing to modify the original type, especially when we don't have access to the original source code.</p>"},{"location":"swift/continued-learning/extensions-in-swift/#extension-syntax","title":"Extension syntax","text":"<p>To create an extension, we use the <code>extension</code> keyword followed by the name of the type we want to extend.</p> <pre><code>extension SomeType {\n    // New functionalities to be added\n}\n</code></pre> <p>Let's explore some practical examples to understand how extensions work in Swift.</p>"},{"location":"swift/continued-learning/extensions-in-swift/#adding-custom-functionality-to-existing-types","title":"Adding custom functionality to existing types","text":""},{"location":"swift/continued-learning/extensions-in-swift/#adding-computed-properties","title":"Adding computed properties","text":"<p>Extensions allow us to add computed properties. For example, we can add a computed property that determines if an integer is even or odd.</p> <pre><code>extension Int {\n    var isEven: Bool {\n        self % 2 == 0\n    }\n}\n\nprint(4.isEven) // Outputs: true\nprint(7.isEven) // Outputs: false\n</code></pre>"},{"location":"swift/continued-learning/extensions-in-swift/#adding-methods","title":"Adding Methods","text":"<p>Suppose we have a <code>String</code> type and want to add a method that reverses the string. Instead of modifying the <code>String</code> type itself, we can create an extension that adds a new method.</p> <pre><code>extension String {\n    func reverse() -&gt; String {\n        String(self.reversed())\n    }\n}\n\nprint(\"abc\".reverse()) // Outputs: cba\n</code></pre> <p>If a method needs to modify (or mutate) the instance itself, we need to mark the method as <code>mutating</code>. The example below adds a new mutating method called square to Swift\u2019s Int type, which squares the original value.</p> <pre><code>extension Int {\n    mutating func square() {\n        self = self * self\n    }\n}\n\nvar number = 5\nnumber.square()\nprint(number) // Outputs: 25\n</code></pre>"},{"location":"swift/continued-learning/extensions-in-swift/#adding-initializers","title":"Adding Initializers","text":"<p>Extensions can also provide additional initializers. For example, we can add an initializer that creates a <code>Date</code> instance from a timestamp.</p> <pre><code>extension Date {\n    init?(timestamp: Double) {\n        self.init(timeIntervalSince1970: timestamp)\n    }\n}\n\nlet timestamp = 1693982400.0 // Unix timestamp for 2023-09-06 06:40:00\nif let date = Date(timestamp: timestamp) {\n    print(date) // Outputs: 2023-09-06 06:40:00 +0000\n}\n</code></pre>"},{"location":"swift/continued-learning/extensions-in-swift/#adding-subscripts","title":"Adding Subscripts","text":"<p>Extensions can add new subscripts to an existing type. For example, we can add a subscript that returns the character at a given index in the string.</p> <pre><code>extension String {\n    subscript(index: Int) -&gt; Character {\n        self[self.index(startIndex, offsetBy: index)]\n    }\n}\n\nprint(\"Swift\"[1]) // Outputs: w\n</code></pre>"},{"location":"swift/continued-learning/extensions-in-swift/#adding-functionality-to-custom-types","title":"Adding functionality to custom types","text":""},{"location":"swift/continued-learning/extensions-in-swift/#adding-computed-properties_1","title":"Adding computed properties","text":"<p>We can also add computed properties to a type using extensions. For instance, for the <code>Person</code> class, we might add a computed property that determines if the person is an adult.</p> <pre><code>class Person {\n    var name: String\n    var age: Int\n\n    init(name: String, age: Int) {\n        self.name = name\n        self.age = age\n    }\n}\n\nextension Person {\n    var isAdult: Bool {\n        return age &gt;= 18\n    }\n}\n\nprint(person.isAdult) // Outputs: true\n</code></pre>"},{"location":"swift/continued-learning/extensions-in-swift/#adding-methods_1","title":"Adding methods","text":"<p>Suppose we have a <code>Circle</code> class and want to add a method that calculates the area of the circle. We can do this using extensions.</p> <pre><code>class Circle {\n    var radius: Double\n\n    init(radius: Double) {\n        self.radius = radius\n    }\n}\n\nextension Circle {\n    func area() -&gt; Double {\n        return 3.14 * radius * radius\n    }\n}\n\nlet circle = Circle(radius: 5.0)\nprint(circle.area()) // Outputs: 78.5\n</code></pre>"},{"location":"swift/continued-learning/extensions-in-swift/#constraints-for-extensions","title":"Constraints for extensions","text":"<p>Constraints on extensions in Swift allow us to extend a type only when it meets certain conditions. This is especially useful when we want to add functionality to a type that conforms to a specific protocol or has certain properties.</p> <p>In the example below, we will create an extension on Array that only works when the elements of the array conform to the Numeric protocol. We will add a method called sum() that calculates the sum of the elements in the array.</p> <pre><code>extension Array where Element: Numeric {\n    func sum() -&gt; Element {\n        reduce(0, +)\n    }\n}\n\nlet numbers = [1, 2, 3, 4, 5]\nprint(numbers.sum()) // Outputs: 15\n\nlet doubles = [1.5, 2.5, 3.5]\nprint(doubles.sum()) // Outputs: 7.5\n\n// This will not work because String is not Numeric\n// let strings = [\"a\", \"b\", \"c\"]\n// print(strings.sum())\n// Error: Cannot invoke 'sum' with an array of strings\n</code></pre>"},{"location":"swift/continued-learning/extensions-in-swift/#protocol-extensions","title":"Protocol extensions","text":"<p>In Swift, we can also extend protocols. It works pretty much like abstract classes when regarding a functionality we want to be available in all the classes that implements some protocol (without having to inherit from a base common class).</p> <pre><code>// Define a protocol\nprotocol Describable {\n    func describe() -&gt; String\n}\n\n// Provide a default implementation using a protocol extension\nextension Describable {\n    func describe() -&gt; String {\n        \"This is a generic description\"\n    }\n}\n\n// Define a struct that conforms Describable protocol\nstruct Person: Describable {\n    var name: String\n    var age: Int\n\n    // Overriding the default implementation\n    func describe() -&gt; String {\n        \"My name is \\(name) and I am \\(age) years old.\"\n    }\n}\n\nstruct Employee: Describable {\n    var name: String\n    var age: Int\n\n    // Using the default implementation\n}\n\n// By just implementing the protocol the describe() method is available\n\nlet person = Person(name: \"Ivan\", age: 21)\nlet employee = Employee(name: \"Saul\", age: 25)\n\nprint(person.describe()) // Outputs: My name is Ivan and I am 21 years old.\nprint(employee.describe()) // Outputs: This is a generic description\n</code></pre>"},{"location":"swift/continued-learning/how-to-get-a-sublist-from-a-list-in-swift/","title":"How to get a sublist from a list in Swift","text":"<p>Working with lists (or arrays) in Swift is something we do all the time. Sometimes, we just need a portion of an array (a sublist) without modifying the original data. In this post, we'll explore different ways to extract sublists in Swift, using simple and practical approaches.</p>"},{"location":"swift/continued-learning/how-to-get-a-sublist-from-a-list-in-swift/#using-array-slicing","title":"Using array slicing","text":"<p>The easiest way to get a sublist in Swift is to use the index and range operators. Let's consider the following array:</p> <pre><code>let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n</code></pre> <p>To get a sublist from index <code>2</code> to <code>5</code>, we can use the <code>range</code> operator:</p> <pre><code>let sublist = numbers[2...5]\nprint(sublist) // Output: [3, 4, 5, 6]\n</code></pre> <p>Here we take elements from index <code>2</code> to <code>5</code> including the endpoints. This doesn't copy the data; it just creates an <code>ArraySlice</code> object which is a lightweight view into the original array.</p> <p>If we need a new array instead of a <code>ArraySlice</code>, we can use the <code>Array</code> initializer:</p> <pre><code>let newArray = Array(sublist)\nprint(newArray) // Output: [3, 4, 5, 6]\n</code></pre> <p>Array index is out of range</p> <p>The <code>array slicing</code> is not safe, it can crash your app if you try to access an element that doesn't exist.</p> <pre><code>print(numbers[2...20])\nSwift/Array.swift:418: Fatal error: Array index is out of range\n</code></pre> <p>Getting a Sublist Safely</p> <p>If we're unsure about the indices, we can use <code>prefix(upTo:)</code>, <code>suffix(from:)</code>, or <code>indices.contains(_:)</code> to avoid crashes:</p> <pre><code>if numbers.indices.contains(2) &amp;&amp; numbers.indices.contains(5) {\n    let sublist = numbers[2...5]\n    print(sublist) // Output: [3, 4, 5, 6]\n}\n</code></pre>"},{"location":"swift/continued-learning/how-to-get-a-sublist-from-a-list-in-swift/#using-the-suffix-and-prefix-methods","title":"Using the <code>suffix</code> and <code>prefix</code> methods","text":"<p>Another way to get a sublist is to use the built-in <code>suffix</code> and <code>prefix</code> methods. These methods return a new array containing the last or first <code>n</code> elements of the original array, respectively.</p> <pre><code>let suffix = numbers.suffix(3)\nprint(suffix) // Output: [8, 9, 10]\n\nlet prefix = numbers.prefix(3)\nprint(prefix) // Output: [1, 2, 3]\n</code></pre>"},{"location":"swift/continued-learning/how-to-get-a-sublist-from-a-list-in-swift/#using-the-dropfirst-and-droplast-methods","title":"Using the <code>dropFirst</code> and <code>dropLast</code> methods","text":"<p>We can also use the <code>dropFirst</code> and <code>dropLast</code> methods to get a sublist. These methods remove the first or last <code>n</code> elements from the original array, respectively.</p> <pre><code>let sublist = numbers.dropFirst(3)\nprint(sublist) // Output: [4, 5, 6, 7, 8, 9, 10]\n\nlet sublist = numbers.dropLast(3)\nprint(sublist) // Output: [1, 2, 3, 4, 5, 6, 7]\n</code></pre> <p>Note</p> <p>If the number of elements to drop exceeds the number of elements in the collection, the result is an empty array.</p> <pre><code>print(numbers.dropFirst(20)) // Output: []\nprint(numbers.dropLast(20)) // Output: []\n</code></pre>"},{"location":"swift/continued-learning/how-to-get-a-sublist-from-a-list-in-swift/#using-the-dropwhile-method","title":"Using the <code>drop(while:)</code> method","text":"<p>The <code>drop(while:)</code> method removes elements from the beginning of the array while a condition holds <code>true</code>. Once an element does not meet the condition, the rest of the array is returned.</p> <pre><code>let sublist = numbers.drop(while: { $0 &lt; 5 })\nprint(sublist) // Output: [5, 6, 7, 8, 9, 10]\n</code></pre>"},{"location":"swift/continued-learning/how-to-get-a-sublist-from-a-list-in-swift/#using-the-filter-method","title":"Using the <code>filter</code> method","text":"<p>The <code>filter</code> method is another powerful tool for extracting sublists. It takes a closure as an argument, which is called for each element in the array. If the closure returns <code>true</code>, the element is included in the result; otherwise, it is skipped.</p> <pre><code>let sublist = numbers.filter { $0 % 2 == 0 }\nprint(sublist) // Output: [2, 4, 6, 8, 10]\n</code></pre>"},{"location":"swift/continued-learning/how-to-get-a-sublist-from-a-list-in-swift/#using-the-stride-method","title":"Using the <code>stride</code> method","text":"<p>If we want to extract elements at specific intervals (e.g., every second element), we can use the stride function:</p> <p>The <code>stride(from:to:by:)</code> function allows us to create a sequence of numbers with a specific step. By mapping these indices to array elements, we can efficiently extract every nth element from the array. In this example, we extract every second element, producing a sublist of odd numbers.</p> <pre><code>let sublist = stride(from: 0, to: numbers.count, by: 2)\n    .map { numbers[$0] }\nprint(sublist) // Output: [1, 3, 5, 7, 9]\n</code></pre> <p>Swift offers multiple ways to extract sublists efficiently. Whether we need a simple slice, filtered results, or elements at regular intervals, we have powerful built-in tools at our disposal.</p>"},{"location":"swift/continued-learning/how-to-sort-arrays-in-swift/","title":"How to Sort Arrays in Swift","text":"<p>Sorting is a fundamental operation in software development. Whether we're organizing user data, preparing information for display, or implementing search algorithms, efficient sorting is essential. Swift offers multiple approaches to sorting, each suited for different scenarios. Let's break them down with practical examples.</p>","tags":["Swift","Arrays"]},{"location":"swift/continued-learning/how-to-sort-arrays-in-swift/#sorted-method","title":"<code>sorted()</code> Method","text":"<p>The <code>sorted()</code> method returns a new array with elements arranged in ascending order by default, leaving the original array unchanged.</p> <pre><code>// Sorting numbers\nlet numbers = [5, 2, 7, 1, 9]\nlet sortedNumbers = numbers.sorted()\n// sortedNumbers: [1, 2, 5, 7, 9]\n// numbers remains unchanged\n\n// Sorting strings\nlet fruits = [\"apple\", \"banana\", \"cherry\", \"date\"]\nlet sortedFruits = fruits.sorted()\n// sortedFruits: [\"apple\", \"banana\", \"cherry\", \"date\"]\n</code></pre>","tags":["Swift","Arrays"]},{"location":"swift/continued-learning/how-to-sort-arrays-in-swift/#sort-method","title":"<code>sort()</code> Method","text":"<p>Unlike <code>sorted()</code>, the <code>sort()</code> method modifies the original array directly. This is more memory-efficient when we don\u2019t need to keep the original order.</p> <pre><code>// Sorting in-place\nvar scores = [89, 72, 95, 63, 81]\nscores.sort()\n// scores: [63, 72, 81, 89, 95]\n\nvar countries = [\"Spain\", \"Japan\", \"Brazil\", \"Canada\"]\ncountries.sort()\n// countries: [\"Brazil\", \"Canada\", \"Japan\", \"Spain\"]\n</code></pre> <p>Performance Considerations</p> <p><code>sort()</code> is more memory-efficient than <code>sorted()</code> when we don\u2019t need to keep the original order. This is especially useful when working with large datasets.</p>","tags":["Swift","Arrays"]},{"location":"swift/continued-learning/how-to-sort-arrays-in-swift/#custom-sorting-with-closures","title":"Custom Sorting with Closures","text":"<p>Swift allows us to define custom sorting logic using closures, which is especially useful for complex data types or non-standard sorting criteria.</p>","tags":["Swift","Arrays"]},{"location":"swift/continued-learning/how-to-sort-arrays-in-swift/#using-sortedby","title":"Using <code>sorted(by:)</code>","text":"<pre><code>// Sorting in descending order\nlet ages = [25, 31, 19, 45, 28]\nlet descendingAges = ages.sorted(by: &gt;)\n// Result: [45, 31, 28, 25, 19]\n\n// Alternative syntax with trailing closure\nlet descendingAges2 = ages.sorted { $0 &gt; $1 }\n</code></pre>","tags":["Swift","Arrays"]},{"location":"swift/continued-learning/how-to-sort-arrays-in-swift/#using-sortby","title":"Using <code>sort(by:)</code>","text":"<pre><code>var prices = [29.99, 15.50, 42.75, 8.25]\nprices.sort(by: &gt;)\n// prices: [42.75, 29.99, 15.50, 8.25]\n</code></pre>","tags":["Swift","Arrays"]},{"location":"swift/continued-learning/how-to-sort-arrays-in-swift/#sorting-custom-objects","title":"Sorting Custom Objects","text":"<p>When working with custom types, we need to specify how they should be compared for sorting.</p> <pre><code>struct Product {\n    let name: String\n    let price: Double\n}\n\nlet inventory = [\n    Product(name: \"Laptop\", price: 1299.99),\n    Product(name: \"Phone\", price: 799.99),\n    Product(name: \"Headphones\", price: 159.99),\n    Product(name: \"Tablet\", price: 499.99)\n]\n\n// Sorting by price (ascending)\nlet sortedByPrice = inventory.sorted { $0.price &lt; $1.price }\n// Result: Headphones, Tablet, Phone, Laptop\n\n// Sorting by name (alphabetically)\nlet sortedByName = inventory.sorted { $0.name &lt; $1.name }\n// Result: Headphones, Laptop, Phone, Tablet\n</code></pre>","tags":["Swift","Arrays"]},{"location":"swift/continued-learning/how-to-sort-arrays-in-swift/#combining-multiple-sorting-criteria","title":"Combining Multiple Sorting Criteria","text":"<p>Suppose we have an array of <code>User</code> objects, and we want to sort them based on complex rule that is not directly supported by simple closures.</p> <pre><code>struct User {\n    let name: String\n    let age: Int\n}\n\nlet users = [\n    User(name: \"John\", age: 25),\n    User(name: \"Alice\", age: 30),\n    User(name: \"Jane\", age: 40),\n    User(name: \"Bob\", age: 30),\n]\n\n// Sorting by age (ascending) and then by name (alphabetically)\nlet sortedByAgeAndName = users.sorted {\n    if $0.age == $1.age {\n        return $0.name &lt; $1.name\n    }\n    return $0.age &lt; $1.age\n}\n// Result: John(25), Alice(30), Bob(30), Jane(40)\n</code></pre> <p>In this example, first sort users by age, and then if the ages are the same, sort them by name alphabetically.</p>","tags":["Swift","Arrays"]},{"location":"swift/continued-learning/how-to-sort-arrays-in-swift/#making-custom-types-sortable","title":"Making Custom Types Sortable","text":"<p>To simplify sorting, we can make our types conform to the <code>Comparable</code> protocol.</p> <pre><code>struct Task{\n    let title: String\n    let priority: Int\n}\n\nextension Task: Comparable {\n    static func &lt; (lhs: Task, rhs: Task) -&gt; Bool {\n        return lhs.priority &gt; rhs.priority // Higher priority first\n    }\n}\n\nlet tasks = [\n    Task(title: \"Check emails\", priority: 2),\n    Task(title: \"Update documentation\", priority: 3),\n    Task(title: \"Fix bug\", priority: 5),\n    Task(title: \"Schedule meeting\", priority: 1)\n]\n\n// Sorting is now effortless\nlet sortedTasks = tasks.sorted()\n// Result: [\"Fix bug\", \"Update documentation\", \"Check emails\", \"Schedule meeting\"]\n</code></pre>","tags":["Swift","Arrays"]},{"location":"swift/continued-learning/how-to-sort-arrays-in-swift/#conclusion","title":"Conclusion","text":"<p>Swift provides a robust and flexible set of tools for sorting data efficiently. Whether sorting simple arrays or complex objects, choosing the right method depends on factors such as memory efficiency, performance, and the need for custom sorting logic. By understanding these sorting techniques, we can write cleaner, more optimized, and maintainable code.</p>","tags":["Swift","Arrays"]},{"location":"swiftui/","title":"SwiftUI","text":"<p>SwiftUI is a modern user interface framework for building native apps for iOS, macOS, watchOS, and tvOS.</p> <ul> <li> SwiftUI Text</li> <li> How to Add Custom Fonts in SwiftUI</li> <li> SwiftUI Animations</li> </ul>"},{"location":"swiftui/continued-learning/how-to-add-custom-fonts-in-swiftui/","title":"How to Add Custom Fonts in SwiftUI","text":"<p>Integrating custom fonts into your SwiftUI app can significantly enhance its visual appeal and user experience. This guide will walk you through the steps to add custom fonts to your SwiftUI application.</p>"},{"location":"swiftui/continued-learning/how-to-add-custom-fonts-in-swiftui/#setting-up-your-project","title":"Setting Up Your Project","text":"<p>To begin, you need the font files you wish to use. These files are typically in <code>.ttf</code> (TrueType Font) or <code>.otf</code> (OpenType Font) formats. You can find a variety of fonts on sites like Google Fonts, which offers an extensive collection of open-source fonts.</p> <p></p>"},{"location":"swiftui/continued-learning/how-to-add-custom-fonts-in-swiftui/#adding-font-files-to-your-project","title":"Adding Font Files to Your Project","text":"<ol> <li>Choose and download the font you want to use. Ensure the font is in either <code>.ttf</code> or <code>.otf</code> format.</li> <li>Drag the downloaded font files into your Xcode project. It\u2019s good practice to create a new group (e.g., <code>Fonts</code>) to keep your files organized.</li> <li>When you drag the files into Xcode, ensure that \"Copy items if needed\" is checked and that the files are added to your app\u2019s target.</li> </ol>"},{"location":"swiftui/continued-learning/how-to-add-custom-fonts-in-swiftui/#verifying-font-files-in-xcode","title":"Verifying Font Files in Xcode","text":"<p>To ensure your fonts are correctly added, follow these steps:</p> <ol> <li>Go to your project\u2019s settings.</li> <li>Navigate to the <code>Build Phases</code> tab.</li> <li>Under <code>Copy Bundle Resources</code>, confirm that your font files are listed.</li> </ol> <p></p>"},{"location":"swiftui/continued-learning/how-to-add-custom-fonts-in-swiftui/#updating-the-infoplist-file","title":"Updating the <code>Info.plist</code> File","text":"<p>To make the fonts available to your app, you need to update the <code>Info.plist</code> file:</p> <ol> <li>Go to your project\u2019s settings.</li> <li>Navigate to the <code>Info</code> tab.</li> <li>Add a new key: <code>Fonts provided by application</code>.</li> <li>Add each font file, ensuring you include the correct file name and extension.</li> </ol> <p></p>"},{"location":"swiftui/continued-learning/how-to-add-custom-fonts-in-swiftui/#using-custom-fonts-in-swiftui","title":"Using Custom Fonts in SwiftUI","text":"<p>With your fonts added and configured, you can now use them in your SwiftUI views. The basic way to display text in SwiftUI is with the <code>Text</code> view. To use a custom font, use the <code>.font</code> modifier with the <code>.custom</code> method.</p> <pre><code>import SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n        VStack {\n            Text(\"Hello, SwiftUI!\")\n                .font(.custom(\"MontserratRoman-Bold\", size: 48))\n                .foregroundStyle(.orange)\n\n            Text(\"Custom Fonts are Great!\")\n                .font(.custom(\"Montserrat-Thin\", size: 25))\n        }\n    }\n}\n\n#Preview {\n    ContentView()\n}\n</code></pre> <p>Replace <code>\"Montserrat\"</code>  with the exact names of your font files (excluding the file extension).</p>"},{"location":"swiftui/continued-learning/how-to-add-custom-fonts-in-swiftui/#handling-font-failures","title":"Handling Font Failures","text":"<p>It's important to provide a fallback font in case your custom font fails to load. You can do this by using the <code>.font</code> modifier conditionally:</p> <pre><code>Text(\"Hello, SwiftUI!\")\n    .font(Font.custom(\"MyCustomFont-Regular\", size: 24) ?? .system(size: 24))\n</code></pre>"},{"location":"swiftui/continued-learning/how-to-add-custom-fonts-in-swiftui/#finding-the-correct-font-name","title":"Finding the Correct Font Name","text":"<p>Sometimes, determining the exact name of a font can be tricky. You can list all available fonts in your app to find the correct font name. Add the following code in your app\u2019s initialization:</p> <pre><code>init() {\n    for family in UIFont.familyNames {\n        print(family)\n        for names in UIFont.fontNames(forFamilyName: family) {\n            print(\"== \\(names)\")\n        }\n    }\n}\n</code></pre> <p>Running this code will print a list of all font families and their respective font names, helping you identify the correct name to use.</p> <p></p>"},{"location":"swiftui/continued-learning/swiftui-animations/","title":"SwiftUI Animations","text":"<p>SwiftUI provides a wide range of animations that we can use to bring your app to life. These animations can be used to create dynamic and engaging user interfaces. In this guide, we will explore the different types of animations available in SwiftUI and learn how to use them effectively.</p>"},{"location":"swiftui/continued-learning/swiftui-animations/#getting-started","title":"Getting Started","text":"<p>The word \"animation\" comes from the Latin word \"animare,\" which means to move or change. In SwiftUI, animations are used to create the illusion of movement or change in our app's user interface.</p>"},{"location":"swiftui/continued-learning/swiftui-animations/#parts-of-an-animation","title":"Parts of an Animation","text":"<p>An animation consists of three main parts:</p> <ol> <li><code>Start</code> \u2013 This is the beginning state of the view.</li> <li><code>Change</code> \u2013 This is where the animation happens.</li> <li><code>End</code> \u2013 This is the final state of the view.</li> </ol> <p>Let's take a look at an example of an animation:</p> <pre><code>struct PartsOfAnimation: View {\n    @State private var isAnimating: Bool = false\n\n    var body: some View {\n        VStack {\n            Circle()\n                .fill(.blue)\n                .frame(width: 100, height: 100)\n                .offset(y: isAnimating ? 300 : 0) // 2. (2)\n                .animation(.easeInOut, value: isAnimating) // 3. (3)\n\n            Spacer()\n\n            Button(\"Start Animation\") {\n                isAnimating.toggle() // 1. (1)\n            }\n            .buttonStyle(.bordered)\n        }\n    }\n}\n</code></pre> <ol> <li>The button triggers a variable's value to change.</li> <li>The variable's value changing causes the <code>Circle</code> Y position to change.</li> <li>Animate the change between the start and end states.</li> </ol> <p>In this example, we have a <code>Circle</code> view that is initially positioned at the top of the screen. When the user taps the \"Start Animation\" button, the <code>isAnimating</code> variable is toggled, causing the <code>Circle</code> to move down the screen.</p> <p>What else can be animated?</p> <p>Most, if not all, of the properties that can be animated have a numerical value. For example, the <code>opacity</code>, <code>scale</code>, and <code>rotation</code> properties can be animated.</p>"},{"location":"swiftui/continued-learning/swiftui-animations/#animation-curves","title":"Animation Curves","text":"<p>An animation curve is a way to describe the speed through the duration of an animation. In the previous example, we used the <code>easeInOut</code> curve to animate the <code>Circle</code> view. Graphically, the curve looks like this:</p> The easeInOut curve <p>Note</p> <p>The <code>easeInOut</code> means that the animation starts slowly(easeIn), and then speeds up, and then slows down again(easeIn).</p> <p>There are several other animation curves available in SwiftUI</p> <ul> <li><code>easeInOut</code> | <code>.default</code>: Starts slow, speeds up and then slows down again at the end.</li> <li><code>easeIn</code>: Starts slow and the speeds up.</li> <li><code>easeOut</code>: Slows down at the end.</li> <li><code>linear</code>: Maintains a constant speed throughout the duration of the animation.</li> <li><code>spring</code>: Creates a springy effect.</li> </ul> Animation curves <p>Let\u2019s look at examples of each curve. The duration is set to 2 seconds.</p> Show example code TextView.swift<pre><code>//\n//  AnimationCurves.swift\n//  SwiftUIPG\n//\n//  Created by @ivansaul on 2/22/25.\n//\n//  https://github.com/ivansaul\n//\n\nimport SwiftUI\n\nstruct AnimationCurves: View {\n    @State private var isAnimating: Bool = false\n\n    var body: some View {\n        VStack(spacing: 20) {\n            itemRow(title: \"linear\", animation: .linear(duration: 2))\n            itemRow(title: \"easeIn\", animation: .easeIn(duration: 2))\n            itemRow(title: \"easeOut\", animation: .easeOut(duration: 2))\n            itemRow(title: \"easeInOut\", animation: .easeInOut(duration: 2))\n            itemRow(title: \"spring\", animation: .spring(response: 2))\n\n            Button(\"Start\") {\n                isAnimating.toggle()\n            }\n            .buttonStyle(.bordered)\n        }\n        .padding()\n    }\n\n    func itemRow(title: String, animation: Animation) -&gt; some View {\n        VStack {\n            HStack {\n                Text(title)\n                    .font(.subheadline)\n                    .fontWeight(.semibold)\n                    .foregroundStyle(.blue)\n                    .frame(width: 90, alignment: .leading)\n\n                Image(systemName: \"tortoise.fill\")\n                    .foregroundStyle(.orange)\n                    .offset(x: isAnimating ? 200 : 0)\n                    .animation(animation, value: isAnimating)\n\n                Spacer()\n            }\n            Divider()\n        }\n    }\n}\n\n#Preview {\n    AnimationCurves()\n}\n</code></pre>"},{"location":"swiftui/getting-started/swiftui-text/","title":"SwiftUI Text","text":"<p><code>Text</code> views are one of the most fundamental and frequently used components in any SwiftUI user interface. They enable us to display text in our apps, serving as labels, titles, descriptions, and much more. SwiftUI's <code>Text</code> views are simple to use, require minimal code, and offer a wide range of customization options.</p> Source code TextView.swift<pre><code>//\n//  TextView.swift\n//  SwiftUIPG\n//\n//  Created by @ivansaul on 12/2/24.\n//\n//  https://github.com/ivansaul\n//\n\nimport SwiftUI\n\n// struct TextView: View {\n//    var body: some View {\n//        Text(\"Hello, World!\")\n//    }\n// }\n\n// struct TextView: View {\n//    var body: some View {\n//        Text(\"Hello, World!\")\n//            .font(.headline)\n//    }\n// }\n\n// struct TextView: View {\n//    var body: some View {\n//        Text(\"Hello, World!\")\n//            .fontWeight(.light)\n//    }\n// }\n\n// struct TextView: View {\n//    var body: some View {\n//        Text(\"Hello, World!\")\n//            .foregroundStyle(.orange)\n//    }\n// }\n\n// struct TextView: View {\n//    var body: some View {\n//        Text(\"Hello, World!\")\n//            .italic()\n//    }\n// }\n\n// struct TextView: View {\n//    var body: some View {\n//        Text(\"Hello, World!\")\n//            .underline()\n//    }\n// }\n\n// struct TextView: View {\n//    var body: some View {\n//        Text(\"Hello, World!\")\n//            .shadow(color: .gray, radius: 2, x: 0, y: 2)\n//    }\n// }\n\n// struct TextView: View {\n//    var body: some View {\n//        Text(\"Hello, World!\")\n//            .font(.headline)\n//            .foregroundColor(.orange)\n//            .italic()\n//            .underline()\n//            .shadow(color: .gray, radius: 2, x: 0, y: 2)\n//            .strikethrough(true, color: .red)\n//    }\n// }\n\nstruct TextView: View {\n    var body: some View {\n        Text(\"Hello, World!\\nWelcome to SwiftUI\\nThe future of app development\")\n            .lineSpacing(5)\n            .lineLimit(2)\n            .multilineTextAlignment(.trailing)\n    }\n}\n\n#Preview(traits: .sizeThatFitsLayout) {\n    TextView()\n        .padding()\n}\n</code></pre>"},{"location":"swiftui/getting-started/swiftui-text/#basic-text-view","title":"Basic Text View","text":"<p>The simplest way to create a <code>Text</code> view is by using the <code>Text</code> initializer with a string literal. This creates a view that displays the specified text.</p> <pre><code>import SwiftUI\n\nstruct TextView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n    }\n}\n\n#Preview {\n    TextView()\n}\n</code></pre> <p>In this example, the <code>TextView</code> struct conforms to the <code>View</code> protocol and defines a <code>body</code> property that returns a <code>Text</code> view with the text \"Hello, World!\". The <code>#Preview</code> directive is used to preview the view in the Xcode preview area.</p>"},{"location":"swiftui/getting-started/swiftui-text/#text-styles","title":"Text Styles","text":"<p>One of the powerful features of SwiftUI is the ability to customize views using modifiers. Let's explore some of the common modifiers that can be used with <code>Text</code> views.</p>"},{"location":"swiftui/getting-started/swiftui-text/#font-style","title":"Font Style","text":"<p>We can use the <code>font</code> modifier to change the font of a <code>Text</code> view. Here's how to set the text to a headline style:</p> <pre><code>import SwiftUI\n\nstruct TextView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n            .font(.headline) // (1)!\n    }\n}\n</code></pre> <ol> <li>If we want to use a custom font, we need to use the <code>font</code> modifier combined with the <code>custom</code> modifier, <code>.font(.custom(\"Arial\", size: 20))</code> will set the font to Arial with a size of 20.</li> </ol>"},{"location":"swiftui/getting-started/swiftui-text/#font-weight","title":"Font Weight","text":"<p>We can use the <code>fontWeight</code> modifier to change the font weight of a <code>Text</code> view. Here's how to set the text to a <code>light</code> weight:</p> <pre><code>import SwiftUI\n\nstruct TextView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n            .fontWeight(.light)\n    }\n}\n</code></pre>"},{"location":"swiftui/getting-started/swiftui-text/#text-color","title":"Text Color","text":"<p>To change the color of a <code>Text</code> view, we can use the <code>foregroundColor</code> modifier.</p> <pre><code>import SwiftUI\n\nstruct TextView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n            .foregroundColor(.orange)\n    }\n}\n</code></pre>"},{"location":"swiftui/getting-started/swiftui-text/#text-italic","title":"Text Italic","text":"<p>We can use the <code>italic</code> modifier to make the text italic.</p> <pre><code>import SwiftUI\n\nstruct TextView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n            .italic()\n    }\n}\n</code></pre>"},{"location":"swiftui/getting-started/swiftui-text/#text-underline","title":"Text Underline","text":"<p>We can use the <code>underline</code> modifier to underline the text.</p> <pre><code>import SwiftUI\n\nstruct TextView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n            .underline()\n    }\n}\n</code></pre>"},{"location":"swiftui/getting-started/swiftui-text/#text-shadow","title":"Text Shadow","text":"<p>We can use the <code>shadow</code> modifier to add a shadow to the text.</p> <pre><code>import SwiftUI\n\nstruct TextView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n             .shadow(color: .gray, radius: 2, x: 0, y: 2)\n    }\n}\n</code></pre>"},{"location":"swiftui/getting-started/swiftui-text/#applying-multiple-modifiers","title":"Applying Multiple modifiers","text":"<p>We can apply multiple modifiers to a <code>Text</code> view by chaining them together.</p> <pre><code>import SwiftUI\n\nstruct TextView: View {\n    var body: some View {\n        Text(\"Hello, World!\")\n            .font(.headline)\n            .foregroundColor(.orange)\n            .italic()\n            .underline()\n            .shadow(color: .gray, radius: 2, x: 0, y: 2)\n            .strikethrough(true, color: .red)\n    }\n}\n</code></pre> <p>As you can see, the <code>Text</code> view now has a headline style, orange color, italic text, and a shadow effect.</p> <p>Another useful modifier are the <code>multilineTextAlignment</code>, <code>lineLimit</code>, and lineSpacing` modifiers. Let's see how they work.</p> <pre><code>import SwiftUI\n\nstruct TextView: View {\n    var body: some View {\n        Text(\"Hello, World!\\nWelcome to SwiftUI\\nThe future of app development\")\n            .lineSpacing(5)\n            .lineLimit(2)\n            .multilineTextAlignment(.trailing)\n    }\n}\n</code></pre> <p>In the example above, the <code>Text</code> view is a multiline text. The <code>lineLimit</code> modifier is used to limit the number of lines, in this case, to 2.</p> <p>That's it! We've covered the basics of <code>Text</code> views in SwiftUI. In the next posts, we'll explore how to use <code>Text</code> views to create more complex user interfaces.</p>"}]}